# pylint: disable = R0903,E0401,C0111,C0103
"""
Serilizers for Data Conversion
JSON  <--->  Django Objects
"""
from rest_framework import serializers
from rest_framework.exceptions import ValidationError
from api.config_app import FORMAT_PERMISSION_CODENAME
from api.config_restrict_fields import restrict_fields


def getGenericSerializer(model_arg, model_validations, choice_fields):
    """
    Simple generic serializer to serialize all
    the fields of the Model without relation
    :param model_arg:model for serializer
    :param model_validations:model validations to be applied 
    :param choice_fields:if model contains multiselectfield
    :return:model specific serializer with dynamic binding of validation hooks
    """

    class GenericSerializer(serializers.ModelSerializer):
        # checkboxgroup = fields.MultipleChoiceField(choices=choices1)
        locals().update(choice_fields)

        class Meta:
            # locals().update(validators_d)
            model = model_arg
            fields = '__all__'

        def create(self, validated_data):
            obj_create = self.Meta.model
            return obj_create.objects.create(**validated_data)

        def update(self, instance, validated_data):
            for attr, value in validated_data.items():
                setattr(instance, attr, value)
            instance.save()
            return instance

        def to_internal_value(self, request_data):
            errors = {}
            ret = super(GenericSerializer, self).to_internal_value(request_data)
            current_user = self.context['request'].user
            codename = self.context['codename']
            if current_user.groups.filter(permissions__codename=codename).exists():
                return ret
            if errors:
                raise ValidationError(errors)
            return ret

    return GenericSerializer


def GenericSerializerField(model_arg, model_validations, choice_fields, restrict_fields):
    """
    Special Field Serializer
    Only for PUT method
    :param model_arg:model for serializer
    :param model_validations:model validations to be applied 
    :param choice_fields:if model contains multiselectfield
    :param restrict_fields:restrict the fields to be edit
    :return:model specific serializer with dynamic binding of validation hooks
    """

    class GenericSerialField(serializers.ModelSerializer):
        locals().update(choice_fields)

        class Meta:
            # locals().update(validators_d)
            model = model_arg
            fields = '__all__'
            locals().update(restrict_fields)
            # extra_kwargs = {'created_by' :{'read_only' : True}}

        def create(self, validated_data):
            obj_create = self.Meta.model
            return obj_create.objects.create(**validated_data)

        def update(self, instance, validated_data):
            for attr, value in validated_data.items():
                setattr(instance, attr, value)
            instance.save()
            return instance

        def to_internal_value(self, request_data):
            current_user = self.context['request'].user
            codename = self.context['codename']
            ret = super(GenericSerialField, self).to_internal_value(request_data)
            if self.context['model'].created_by == current_user.username:
                return ret
            if current_user.groups.filter(permissions__codename=codename).exists():
                return ret

    return GenericSerialField


def NestedSerializer(model_arg, related_fields, fields_to_fetch):
    """
    Relational Serializer for ONE to MANY
    for models having related fields
    :param model_arg:model for serializer
    :param related_fields:the related fields of the model
    :param fields_to_fetch:display only subset of fields
    :return:model specific serializer 
    """

    class Testrelationserializer(serializers.ModelSerializer):
        locals().update(related_fields)

        class Meta:
            model = model_arg
            fields = fields_to_fetch

        def create(self, validated_data):
            obj_create = self.Meta.model
            return obj_create.objects.create(**validated_data)

    return Testrelationserializer


def GenericTrackSerializer(model_arg):
    """
    Supported serializer for ONE to MANY relations
    i.e cities = Cityserializer(many=TRUE)
    :param model_arg:model for serializer
    :return:model specific serializer
    """

    class GenericSerializer(serializers.ModelSerializer):
        class Meta:
            model = model_arg
            fields = ['name']

    return GenericSerializer


def ReverseStringSerializer(model_arg, keys):
    """
    Serializer for relation MANY to ONE Foreignkey Value Serializer
    USED StringRelatedField(many = TRUE)
    :param model_arg:model for serializer
    :param keys:dynamic mapping for nested serializer
    :return:model specific serializer
    """

    class GenericSerializer(serializers.ModelSerializer):
        locals().update(keys)

        def to_representation(self, instance):
            ret = super(GenericSerializer, self).to_representation(instance)
            restrict_fields(ret)
            current_user = self.context['request'].user
            for field_name, field_value in sorted(ret.items()):
                if current_user.groups.filter(permissions__codename=FORMAT_PERMISSION_CODENAME['view']
                        .format(field_name)).exists():
                    continue
                if current_user.groups.filter(permissions__codename=FORMAT_PERMISSION_CODENAME['restrict']
                        .format(field_name)).exists():
                    ret.pop(field_name)
            return ret

        class Meta:
            model = model_arg
            fields = '__all__'

    return GenericSerializer


def ReverseNestedSerializer(model_arg):
    """
    Reverese serializer for MANY to ONE for Output
    Nested Json
    :param model_arg:model for serializer
    :return:model specific serializer
    """

    class GenericSerializer(serializers.ModelSerializer):
        # locals().update(keys)
        class Meta:
            depth = 10
            model = model_arg
            fields = '__all__'

    return GenericSerializer


def dropdownSerialzer(model_arg):
    """
    Reverese serializer for MANY to ONE for Output
    Nested Json
    :param model_arg:model for serializer
    :return:model specific serializer
    """

    class GenericSerializer(serializers.ModelSerializer):
        # locals().update(keys)
        class Meta:
            model = model_arg
            fields = ["name", model_arg._meta.pk.name]

    return GenericSerializer
