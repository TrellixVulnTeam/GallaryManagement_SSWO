# pylint: disable = E0401,C0301,C0111,R0903,R0201
""" Django Views """
import datetime
import json
from django.apps import apps
from django.conf import settings
from django.contrib.auth import login, logout
from django.contrib.auth.models import Group
from django.core.exceptions import ObjectDoesNotExist
from django.db import transaction, IntegrityError
from django.http import HttpResponse
from rest_framework import status
from rest_framework.authentication import SessionAuthentication, TokenAuthentication
from rest_framework.authtoken.models import Token
from rest_framework.exceptions import APIException
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView
from reversion import revisions as reversion
from api import ExcelExportImport
from api.check_fields import check_fields, multiple_choice_field, \
    ReversionDetectChange, AllVersions
from api.config_app import PERMISSION_PREFIX, QUERY_PARAMS, INITIAL_WORKFLOW_STATUS, PERMISSION_STARTSWITH_PREFIX, \
    WORKFLOW_STATUS_TXT, AUTHENTICATION_ERROR_MSG, API_REQUESTS_ERROR
from api.config_metadata import FILTER_FIELD_MAPPING
from api.custom_exceptions import EmptyBodyException
from api.decorators import SpecificViewDecorator, ListViewDecorator, \
    logger_create, user_logger_create, USER_LOGS, REQ_LOGS
from api.filters import genericSearch, genericfilter
from api.logger_directory import excel_logs
from api.login_serializer import LoginSerializer
from api.serializers import getGenericSerializer, GenericSerializerField, \
    dropdownSerialzer
from django_filters.rest_framework import CharFilter, NumberFilter
from workflow.services import approval_workflow
from commons.backends import WorkflowAuthentication
from commons.functions import get_paginated_queryset


EXCEL_LOGS = excel_logs()
model_validators = settings.__dict__['_wrapped'].__dict__['MODEL_VALIDATORS']
FOREIGN_KEY_UI_NAME_MAP = settings.__dict__['_wrapped'].__dict__['FOREIGN_KEY_UI_NAME_MAP']


def reversion_post(request, serial_data):
    reversion.set_user(request.user)
    reversion.set_comment(request.method)
    reversion.set_date_created(date_created=datetime.datetime.now())
    createdObj = serial_data.save()
    return createdObj


def reversion_put(request, serial_data):
    reversion.set_user(request.user)
    reversion.set_comment(request.method)
    reversion.set_date_created(date_created=datetime.datetime.now())
    createdObj = serial_data.save()
    return createdObj


class GenericMaster(APIView):
    """
    Generic Master for all the Specific operations
    GET     --->  /id
    POST    --->  post
    PUT     --->  /id (update)
    DELETE  --->  /id
    """
    authentication_classes = [TokenAuthentication, SessionAuthentication, WorkflowAuthentication]
    permission_classes = [IsAuthenticated]

    @logger_create
    @SpecificViewDecorator
    def get(self, request, app, model, id):
        """
        GET for Specific
        record
        i.e GET /id
        :param request:the request object
        :param app:the app name coming from decorator
        :param model:the model name coming from decorator
        :param id:id of the model object
        :return:single object
        """
        permission = PERMISSION_PREFIX['view'] + model.lower()
        model = apps.get_model(app, model)
        if request.user.groups.filter(permissions__codename=permission).exists():

            if id:
                try:
                    dataset = model.objects.filter(pk=id, is_deleted=False)
                    modelSerializer = check_fields(model)
                    if len(dataset) != 0:
                        serial = modelSerializer(dataset[0], context={"request": request, "group": None})
                        return Response(serial.data, status=status.HTTP_200_OK)
                    else:
                        raise ObjectDoesNotExist
                except ObjectDoesNotExist:
                    REQ_LOGS.error("Requested Object Doesn't Exist"
                                   + str(ObjectDoesNotExist))
                    return Response({"Error": API_REQUESTS_ERROR['obj_error']}, status=status.HTTP_400_BAD_REQUEST)
        else:
            return Response({"Error": API_REQUESTS_ERROR['permission_error']}, status=status.HTTP_403_FORBIDDEN)

    @logger_create
    @SpecificViewDecorator
    def post(self, request, app, model):
        """
        POST the DATA
        i.e   Actual POST
        Works only for the Dedicated Model Fields
        No Relational Data POST

        :param request:the request object
        :param app:the app name coming from decorator
        :param model:the model name coming from decorator
        :return:newly created object
        """
        permission = PERMISSION_PREFIX['add'] + model.lower()
        if request.user.groups.filter(permissions__codename=permission).exists():
            model_obj = apps.get_model(app, model)
            req_d = request.data
            try:
                if not req_d:
                    raise EmptyBodyException
                choice_fields = multiple_choice_field(model_obj)
                serialize = getGenericSerializer(model_obj,
                                                 model_validators[model.lower()](
                                                     req_d) if model.lower() in model_validators.keys() else None,
                                                 choice_fields
                                                 )
                req_d['status'] = INITIAL_WORKFLOW_STATUS['Draft']
                req_d['created_date'] = datetime.datetime.now()
                req_d['created_by'] = request.user.username
                req_d['last_updated_by'] = request.user.username
                req_d['last_updated_date'] = datetime.datetime.now()
                serial_data = serialize(data=req_d, context={"request": request, "group": None,
                                                             "codename": permission})
                if serial_data.is_valid():
                    with transaction.atomic(), reversion.create_revision():
                        createdObj = reversion_post(request, serial_data)
                        REQ_LOGS.info(
                            "POST by -- {} DATA -- {} IP -- {}".format(str(request.user), str(serial_data.data),
                                                                       str(request.META.get('REMOTE_ADDR'))))
                        REQ_LOGS.info("POST Successfully Executed by -- {} -- IP -- {}".format(str(request.user), str(
                            request.META.get('REMOTE_ADDR'))))

                        # start the Approval Workflow here
                        obj = {"request": request, "app": app, "model": model, "pk": createdObj.pk,
                               "action": "Init", "remarks": ""}
                        approval_workflow(**obj)

                    return Response(serial_data.data, status=status.HTTP_201_CREATED)
                return Response(serial_data.errors, status=status.HTTP_400_BAD_REQUEST)
            except EmptyBodyException:
                REQ_LOGS.info(
                    " POST Error by -- {} -- IP -- {}".format(str(request.user), request.META.get('REMOTE_ADDR')))
                REQ_LOGS.error("In valid Json provided for POST by -- {}".format(str(request.user)))
                return Response({"Error": API_REQUESTS_ERROR['json_error']}, status=status.HTTP_400_BAD_REQUEST)
            except Exception as e:
                # raise e
                REQ_LOGS.debug("In valid Json provided for POST", e)
                REQ_LOGS.info(" -- POST Error by -- {} -- IP -- {}".format(str(request.user),
                                                                           str(request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.exception(e)
                return Response({"Error": API_REQUESTS_ERROR['json_error']}, status=status.HTTP_403_FORBIDDEN)
        else:
            return Response({"Error": API_REQUESTS_ERROR['permission_error']}, status=status.HTTP_403_FORBIDDEN)

    @logger_create
    @SpecificViewDecorator
    def put(self, request, app, model, id):
        """
        PUT the DATA for specific ID
        i.e    /id
        Updates the DATA for model
        Only for Dedicated fields
        NO UPDATE for Relational Fields
        :param request:the request object
        :param app:the app name coming from decorator
        :param model:the model name coming from decorator
        :param id:id of the model object
        :return:reponse the object changed
        """
        req_d = request.data
        permission = PERMISSION_PREFIX['change'] + model.lower()
        if request.user.groups.filter(permissions__codename=permission).exists():
            try:
                if not req_d:
                    raise EmptyBodyException
                model_obj = apps.get_model(app, model)
                obj = model_obj.objects.get(pk=id)
                if not obj:
                    raise ObjectDoesNotExist
                choice_fields = multiple_choice_field(model_obj)
                # Check if the field change permission exists
                if request.user.groups.filter(
                        permissions__codename__startswith=PERMISSION_STARTSWITH_PREFIX['change_restrict']).exists():
                    permission_list = list(request.user.groups.filter(
                        permissions__codename__startswith=PERMISSION_STARTSWITH_PREFIX['change_restrict']).values(
                        'permissions__codename'))
                    restrict_dict = {}
                    for k in permission_list:
                        if k['permissions__codename'][16:] in req_d.keys():
                            restrict_dict[k['permissions__codename'][16:]] = {'read_only': True}
                            # return Response({"Error": "Access Denied to " +k['codename'] }, status=status.HTTP_403_FORBIDDEN)
                    update_restrict_dict = {}
                    update_restrict_dict['extra_kwargs'] = restrict_dict
                    # if field change exists, serializing the obejct dynamically
                    serializer = GenericSerializerField(model_obj,
                                                        model_validators[model.lower()](
                                                            req_d) if model.lower() in model_validators.keys() else None,
                                                        choice_fields,
                                                        update_restrict_dict
                                                        )
                else:

                    serializer = GenericSerializerField(model_obj,
                                                        model_validators[model.lower()](
                                                            req_d) if model.lower() in model_validators.keys() else None,
                                                        choice_fields,
                                                        {}
                                                        )
                # role = request.user.groups.all()[0].name
                # start the approval workflow here
                # work_obj = WorkflowState(model=model, app=app, request_id=id,
                #                          role=role, state=obj.status)
                # if WORKFLOW_STATUS_TXT in req_d:
                #     req_d[WORKFLOW_STATUS_TXT] = approval_workflow(work_obj, request, req_d[WORKFLOW_STATUS_TXT])
                req_d['last_updated_by '] = request.user.username,
                req_d['last_updated_date '] = datetime.datetime.now()
                serial_data = serializer(obj, data=req_d, partial=True,
                                         context={"request": request, "group": None, "model": model_obj,
                                                  "codename": permission})
                if serial_data.is_valid():
                    with transaction.atomic(), reversion.create_revision():
                        reversion_put(request, serial_data)
                        REQ_LOGS.info(
                            "PUT by --> {} DATA --> {} IP -- {}".format(str(request.user), str(serial_data.data),
                                                                        str(request.META.get('REMOTE_ADDR'))))
                        REQ_LOGS.info("PUT executed Successfully by {} -- IP -- {}".format(str(request.user), str(
                            request.META.get('REMOTE_ADDR'))))

                    return Response(serial_data.data, status=status.HTTP_200_OK)
                return Response(serial_data.errors, status=status.HTTP_400_BAD_REQUEST)
            except ObjectDoesNotExist as e:
                REQ_LOGS.info(
                    " Requested object doesn't exist - PUT Failed by -- {} -- IP -- {}".format(str(request.user), str(
                        request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.debug(" Requested object doesn't exist by -- {} -- IP -- {}".format(str(request.user), str(
                    request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.exception(e)
                return Response({"Error": API_REQUESTS_ERROR['obj_error']}, status=status.HTTP_400_BAD_REQUEST)
            except IntegrityError as e:
                REQ_LOGS.info(" PUT Failed - Integrity Error by -- {} -- IP -- {}".format(str(request.user), str(
                    request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.debug(" PUT Failed - Integrity Error by -- {} -- IP -- {}".format(str(request.user), str(
                    request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.exception(e)
            except EmptyBodyException as e:
                REQ_LOGS.info(
                    " Error -- PUT Failed -- empty request body by -- {} -- IP -- {}".format(str(request.user), str(
                        request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.debug(
                    " Error -- PUT Failed -- empty request body by -- {} -- IP -- {}".format(str(request.user), str(
                        request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.exception(e)
                return Response({"Error": API_REQUESTS_ERROR['json_error']}, status=status.HTTP_400_BAD_REQUEST)
            except Exception as e:
                # raise e
                REQ_LOGS.info(
                    "PUT Error -- by {} -- IP -- {}".format(str(request.user), str(request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.debug("In valid Json provided for PUT by {} -- IP -- {}".format(str(request.user), str(
                    request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.exception(e)
                return Response({"Error": "Invalid/Empty JSON for the PUT"}, status=status.HTTP_403_FORBIDDEN)
        else:
            return Response({"Error": API_REQUESTS_ERROR['permission_error']}, status=status.HTTP_403_FORBIDDEN)

    @logger_create
    @SpecificViewDecorator
    def delete(self, request, app, model, id):
        """
           DELETE for Specific ID
        i.e   /id
        Deletes the Whole Record
        :param request:the request object
        :param app:the app name coming from decorator
        :param model:the model name coming from decorator
        :param id:id of the model object
        :return:remaining objects of the model
        """
        permission = PERMISSION_PREFIX['delete'] + model.lower()
        if request.user.groups.filter(permissions__codename=permission).exists():
            if id:
                model = apps.get_model(app, model)
                try:
                    obj = model.objects.get(pk=id)
                    if not obj:
                        raise ObjectDoesNotExist
                    with transaction.atomic(), reversion.create_revision():
                        obj = model.objects.get(pk=id)
                        obj.save()
                        reversion.set_user(request.user)
                        reversion.set_comment(request.method)
                        reversion.set_date_created(date_created=datetime.datetime.now())
                    # obj.delete()
                    obj.is_deleted = True
                    obj.save()
                    REQ_LOGS.info(
                        "Deleted object for ID -- {} -- by -- {} -- IP -- {}".format(str(id), str(request.user), str(
                            request.META.get('REMOTE_ADDR'))))
                    REQ_LOGS.info("Deleted DATA -- {}".format(str(request.user), str(obj.__dict__)))
                    return Response({"message": "Deleted Successfully"},
                                    status=status.HTTP_200_OK)
                except ObjectDoesNotExist:
                    REQ_LOGS.info(" ID doesn't exists by -- {} -- IP -- {}".format(str(request.user), str(
                        request.META.get('REMOTE_ADDR'))))
                    REQ_LOGS.debug("DELETE Object Doesnt Exist for ID -- {} by -- {} -- IP -- {}".format(str(id), str(
                        request.user), str(request.META.get('REMOTE_ADDR'))))
                    REQ_LOGS.exception(" Obejct Doesn't Exist")
                    return Response(API_REQUESTS_ERROR['obj_error'], status=status.HTTP_400_BAD_REQUEST)
                except Exception as e:
                    REQ_LOGS.info("Error -- Delete failed -- by -- {} -- IP -- {}".format(str(request.user), str(
                        request.META.get('REMOTE_ADDR'))))
                    REQ_LOGS.exception(e)
        else:
            return Response({"Error": API_REQUESTS_ERROR['permission_error']}, status=status.HTTP_403_FORBIDDEN)



def handleDropDownData(query_params, model):
    for item in query_params:
        query_params[item] = query_params[item][0]
    add_attr = {QUERY_PARAMS['is_deleted']: False}
    query_params.update(add_attr)
    objs = model.objects.filter(**query_params) \
        .order_by('name').distinct('name')
    serial = dropdownSerialzer(model)
    serializer = serial(objs, many=True)
    return Response(serializer.data, status=status.HTTP_200_OK)



def handleSearchData(app, model, request, page, pageSize):
    try:
        DynamicSearchFilter = genericSearch(model)
        model_obj = apps.get_model(app, model)
        model_filter = DynamicSearchFilter()
        objs = model_obj.objects.filter(is_deleted=False).order_by('-last_updated_date')
        final_qs = model_filter.filter_queryset(request, objs, APIView)
        modelSerializer = check_fields(model_obj)
        paged_queryset = get_paginated_queryset(final_qs, pageSize, page)
        objs = paged_queryset.object_list
        serial = modelSerializer(objs, many=True, context={"request": request, "group": None})
        response = {
            "total": final_qs.count(),
            "results": serial.data
        }
        return Response(response, status=status.HTTP_200_OK)
    except Exception as e:
        REQ_LOGS.exception(e)
        return Response(status=status.HTTP_400_BAD_REQUEST)

def handleFilterData(request, app, model, page, pageSize):
    try:
        if request.GET.__len__() > 0:
            model_obj = apps.get_model(app, model)
            query_dict = request.GET.dict()
            if "page" in query_dict:
                query_dict.pop('page')
            if "pageSize" in query_dict:
                query_dict.pop('pageSize')
            if "filter" in query_dict:
                query_dict.pop('filter')
            filter_dict = {}
            for i in list(query_dict.keys()):
                if '.name' in i:
                    if FOREIGN_KEY_UI_NAME_MAP[model.lower()]['type'] == 'integer':
                        filter_dict[FOREIGN_KEY_UI_NAME_MAP[model.lower()]['field']] = NumberFilter(
                            lookup_expr='iexact')
                        old_value = query_dict[i]
                        del query_dict[i]
                        i = FOREIGN_KEY_UI_NAME_MAP[model.lower()]['field']
                        query_dict[i] = old_value
                    if FOREIGN_KEY_UI_NAME_MAP[model.lower()]['type'] == 'text':
                        filter_dict[FOREIGN_KEY_UI_NAME_MAP[model.lower()]['field']] = CharFilter(
                            lookup_expr='iexact')
                        old_value = query_dict[i]
                        del query_dict[i]
                        i = FOREIGN_KEY_UI_NAME_MAP[model.lower()]['field']
                        query_dict[i] = old_value
                if '_' in query_dict[i]:
                    values = query_dict[i].split('_')
                    op = values[0]
                    value = "_".join(values[1:])
                    query_dict[i] = value
                    if op in FILTER_FIELD_MAPPING['integer']:
                        filter_dict[i] = NumberFilter(field_name=i, lookup_expr=op)
                    elif op in FILTER_FIELD_MAPPING['text']:
                        filter_dict[i] = CharFilter(field_name=i, lookup_expr=op)
            model_filter = genericfilter(model_obj, filter_dict)
            queryset = model_obj.objects.filter(is_deleted=False)
            f = model_filter(query_dict, queryset=queryset)
            paged_queryset = get_paginated_queryset(f.qs, pageSize, page)
            objs = paged_queryset.object_list
            modelSerializer = check_fields(model_obj)
            serial = modelSerializer(objs, many=True, context={
                "request": request, "group": None})
            response = {
                "total": f.qs.count(),
                "results": serial.data
            }
            return Response(response, status=status.HTTP_200_OK)
        else:
            return Response(status=status.HTTP_400_BAD_REQUEST)
    except Exception as e:
        REQ_LOGS.exception(e)
        return Response(status=status.HTTP_400_BAD_REQUEST)


def retrievePage(query_params):
    page = query_params.pop('page', 1)
    pagesize = query_params.pop('pageSize',15)
    if type(page) is list:
        page = int(page[0])
    else:
        page = int(page)
    if type(pagesize) is list:
        pagesize = int(pagesize[0])
    else:
        pagesize = int(pagesize)

    return page, pagesize

class ListViewDetail(APIView):
    """
    ListViewDetail for all the /LIST Operations
    GET     --->   /list
    POST    --->   /list (Conditional GET)
    DELETE  --->  /list (Conditional DELETE)
    """
    authentication_classes = [TokenAuthentication, SessionAuthentication, WorkflowAuthentication]
    # authentication_classes = [CustomLDAPBackend]
    permission_classes = [IsAuthenticated]

    @logger_create
    @ListViewDecorator
    def get(self, request, app, model):
        """
         GET for all
        i.e   /list
        :param request:the request object
        :param app:the app name coming from decorator
        :param model:the model name coming from decorator
        :return: all the objects of the model
        """

        # permission = PERMISSION_PREFIX['view'] + model.lower()
        # model = apps.get_model(app, model)
        # if request.user.groups.filter(permissions__codename=permission).exists():
        #     # check if the request if, for dropdown UI request
        #     if request.GET.__len__() > 0:
        #         my_dict = dict(request.GET)
        #         for item in my_dict:
        #             my_dict[item] = my_dict[item][0]
        #         add_attr = {QUERY_PARAMS['is_deleted']: False}
        #         my_dict.update(add_attr)
        #         objs = model.objects.filter(**my_dict) \
        #             .order_by('name').distinct('name')
        #         serial = dropdownSerialzer(model)
        #         serializer = serial(objs, many=True)
        #         return Response(serializer.data, status=status.HTTP_200_OK)
        #     # else the grid =view requests (i.e is_active=true and false )
        #     objs = model.objects.filter(is_deleted=False).order_by('-last_updated_date')
        #     modelSerializer = check_fields(model)
        #     serial = modelSerializer(objs, many=True, context={"request": request, "group": None})
        #     return Response(serial.data, status=status.HTTP_200_OK)
        # else:
        #     return Response({"Error": API_REQUESTS_ERROR['permission_error']}, status=status.HTTP_403_FORBIDDEN)

        permission = PERMISSION_PREFIX['view'] + model.lower()
        model_obj = apps.get_model(app, model)
        if request.user.groups.filter(permissions__codename=permission).exists():
            page = None
            query_params = dict(request.GET)
            if 'page' in query_params:
                page, pagesize = retrievePage(query_params)
            if query_params and "page" not in query_params and "search" not in query_params and "filter" not in query_params:
                return handleDropDownData(query_params, model_obj)
            elif "search" in query_params:
                return handleSearchData(app, model, request, page, pagesize)
            elif "filter" in query_params:
                return handleFilterData(request, app, model, page, pagesize)
            else:
                objs = model_obj.objects.filter(is_deleted=False).order_by('-last_updated_date')
                total_count = objs.count()
                modelSerializer = check_fields(model_obj)
                paged_queryset = get_paginated_queryset(objs, pagesize, page)
                objs = paged_queryset.object_list
                serial = modelSerializer(objs, many=True, context={"request": request, "group": None})
                if page is not None:
                    response = {
                        "total": total_count,
                        "results": serial.data
                    }
                else:
                    response = serial.data
                return Response(response, status=status.HTTP_200_OK)
        else:
            return Response({"Error": API_REQUESTS_ERROR['permission_error']}, status=status.HTTP_403_FORBIDDEN)

    @logger_create
    @ListViewDecorator
    def post(self, request, app, model):
        """
        POST for Conditional GET
        i.e    /list
        :param request:the request object
        :param app:the app name coming from decorator
        :param model:the model name coming from decorator
        :return:
        """
        if request.data:
            dict_mapp = request.data
            model = apps.get_model(app, model)
            try:
                obj_filter = model.objects.filter(**dict_mapp, is_deleted=False)
                if not obj_filter:
                    raise ObjectDoesNotExist
                modelSerializer = check_fields(model)
                serial = modelSerializer(obj_filter, many=True)
                return Response(serial.data, status=status.HTTP_200_OK)
            except ObjectDoesNotExist as e:
                REQ_LOGS.debug(
                    "Objects doesn't exists for given conditions by -- {} -- IP -- {}".format(str(request.user), str(
                        request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.info(" Conditional GET Failed by -- {} -- IP -- {}".format(str(request.user), str(
                    request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.exception(e)
                return Response({"Error": API_REQUESTS_ERROR['obj_error']},
                                status=status.HTTP_400_BAD_REQUEST)
            except Exception as e:
                REQ_LOGS.info(" Conditional GET Failed by -- {} -- IP -- {}".format(str(request.user), str(
                    request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.exception(e)
                return Response({"Error": API_REQUESTS_ERROR['error']},
                                status=status.HTTP_400_BAD_REQUEST)
        else:
            REQ_LOGS.info(" Conditional GET Failed by -- {} -- IP -- {}".format(str(request.user),
                                                                                str(request.META.get('REMOTE_ADDR'))))
            REQ_LOGS.debug(
                " None Returned for GET without Conditional parameters by --> {} -- IP -- {}".format(str(request.user),
                                                                                                     str(
                                                                                                         request.META.get(
                                                                                                             'REMOTE_ADDR'))))
            return Response({"Error": API_REQUESTS_ERROR['post_error']}, status=status.HTTP_400_BAD_REQUEST)

    @logger_create
    @ListViewDecorator
    def delete(self, request, app, model):
        """
        DELETE for Contidional DELETE
        i.e    /list
        :param request:the request object
        :param app: the app name coming from decorator
        :param model:the model name coming from decorator
        :return:reponse with the remaining data
        """
        permission = PERMISSION_PREFIX['delete'] + model.lower()
        if request.user.groups.filter(permissions__codename=permission).exists():
            if request.data:
                dict_mapp = request.data
                model = apps.get_model(app, model)
                # Multiple Delete for the objects i.e List of objects
                if isinstance(dict_mapp, list):
                    REQ_LOGS.info(
                        " Attempt Deleting MULTIPLE objects for ID's -- {} by -- {} -- IP -- {}".format(str(dict_mapp),
                                                                                                        str(
                                                                                                            request.user),
                                                                                                        str(
                                                                                                            request.META.get(
                                                                                                                'REMOTE_ADDR'))))
                    with transaction.atomic():
                        for i in range(dict_mapp.__len__()):
                            try:
                                objs = model.objects.filter(**dict_mapp[i], is_deleted=False)
                                if not objs:
                                    raise ObjectDoesNotExist
                                with transaction.atomic(), reversion.create_revision():
                                    objs[0].save()
                                    reversion.set_user(request.user)
                                    reversion.set_comment(request.method)
                                    reversion.set_date_created(date_created=datetime.datetime.now())
                                # objs.delete()
                                objs[0].is_deleted = True
                                objs[0].save()
                                REQ_LOGS.info(" DELETED -- {}".format(str(dict_mapp[i])))
                                REQ_LOGS.info(
                                    "DELETE by -- {} DATA -- {} -- IP -- {} ".format(str(request.user),
                                                                                     str(objs[0].__dict__), str(
                                            request.META.get('REMOTE_ADDR'))))
                            except ObjectDoesNotExist as e:
                                REQ_LOGS.info(" Further DELETE FAILED by --> {}".format(str(request.user)))
                                REQ_LOGS.debug(" Further Objects Doesnt Exist for DELETE by -- {} -- IP -- {}".format(
                                    str(request.user), str(request.META.get('REMOTE_ADDR'))))
                                REQ_LOGS.exception(e)
                                return Response({"Error": API_REQUESTS_ERROR['obj_error']},
                                                status=status.HTTP_400_BAD_REQUEST)
                            except (IntegrityError, APIException) as e:
                                REQ_LOGS.debug(
                                    "Data INtegrity Exception occured by -- {} -- IP -- {}".format(str(request.user),
                                                                                                   str(request.META.get(
                                                                                                       'REMOTE_ADDR'))))
                                REQ_LOGS.info("Delete failed by {} -- IP -- {}".format(str(request.user), str(
                                    request.META.get('REMOTE_ADDR'))))
                                REQ_LOGS.exception(e)
                                return Response({"Error": API_REQUESTS_ERROR['error']},
                                                status=status.HTTP_400_BAD_REQUEST)
                else:
                    # delete for Matching Conditions for the objects
                    try:
                        objs = model.objects.filter(**dict_mapp, is_deleted=False)
                        REQ_LOGS.info(
                            "Attempt Deleting CONDITIONAL objects for Conditon  -- {} by -- {} -- IP --{}".format(
                                str(dict_mapp), str(request.user), str(request.META.get('REMOTE_ADDR'))))
                        if not objs:
                            raise ObjectDoesNotExist
                        with transaction.atomic(), reversion.create_revision():
                            # [objs[i].save() for i in range(len(objs))]
                            for i in range(len(objs)):
                                objs[i].is_deleted = True
                                objs[i].save()
                                REQ_LOGS.info(
                                    "DELETE by -- {} DATA -- {} -- IP -- {}".format(str(request.user),
                                                                                    str(objs[i].__dict__), str(
                                            request.META.get('REMOTE_ADDR'))))
                            reversion.set_user(request.user)
                            reversion.set_comment(request.method)
                            reversion.set_date_created(date_created=datetime.datetime.now())
                            # objs.delete()
                            REQ_LOGS.info(
                                " DELETED objects Successfully for Matching Conditions -- {} -- by -- {} -- IP -- {} ".format(
                                    str(dict_mapp), str(request.user), str(request.META.get('REMOTE_ADDR'))))
                    except ObjectDoesNotExist as e:
                        REQ_LOGS.info(" DELETE FAILED ")
                        REQ_LOGS.debug(
                            " Objects Doesn't Exists for given matching conditions by -- {} -- IP -- {}".format(
                                str(request.user), str(request.META.get('REMOTE_ADDR'))))
                        REQ_LOGS.exception(e)
                        return Response({"Error": API_REQUESTS_ERROR['obj_error']},
                                        status=status.HTTP_400_BAD_REQUEST)
                    except (IntegrityError, APIException) as e:
                        REQ_LOGS.warning(" Data Integrity not maintained", e)
                        REQ_LOGS.debug(" Delete failed APIException")
                        REQ_LOGS.info(" Delete Failed by -- {} -- IP -- {}".format(str(request.user), str(
                            request.META.get('REMOTE_ADDR'))))
                        REQ_LOGS.exception(e)
                        return Response({"Error": API_REQUESTS_ERROR['error']},
                                        status=status.HTTP_400_BAD_REQUEST)

                return Response({'Received Conditional data': request.data}, status=status.HTTP_200_OK)
            else:
                REQ_LOGS.info(
                    " Delete Failed -- No Conditional Parameters by -- {} -- IP -- {}".format(str(request.user), str(
                        request.META.get('REMOTE_ADDR'))))
                REQ_LOGS.debug(" None Deleted without deletion parameters by -- {} -- {}  ".format(str(request.user),
                                                                                                   str(request.META.get(
                                                                                                       'REMOTE_ADDR'))))
                return Response({"Error": API_REQUESTS_ERROR['delete_error']}, status=status.HTTP_400_BAD_REQUEST)
        else:
            return Response({"Error": API_REQUESTS_ERROR['permission_error']}, status=status.HTTP_403_FORBIDDEN)


class LoginView(APIView):
    @user_logger_create
    def post(self, request):
        """
        Login view for user Login and Authentication
        provided the username and Password in Json via POST
        and Token Generation
        :param request: the request object
        :return:Token for success else error with message
        """

        serializer = LoginSerializer(data=request.data)
        grp, created = Group.objects.get_or_create(name="default")
        if serializer.is_valid():
            user = serializer.validated_data["user"]
            status = serializer.validated_data["status"]
            error = serializer.validated_data["error"]
            # type = serializer.validated_data["type"]
            if user:
                login(request, user)
                token, created = Token.objects.get_or_create(user=user)
                grp = Group.objects.get(name="default")
                grp.user_set.add(user)
                # add_user(user, type)
                REQ_LOGS.info("Token Successful for user -- {} -- IP -- {}".format(str(user), str(
                    request.META.get('REMOTE_ADDR'))))
                USER_LOGS.info("Token Successful for user -- {} -- IP -- {}".format(str(user), str(
                    request.META.get('REMOTE_ADDR'))))
                return Response({"Your Token": token.key, "status": status}, status=200)
            elif error == AUTHENTICATION_ERROR_MSG["Invalid Credentials"]:
                return Response({"message": error, "status": status}, status=400)
            else:
                return Response({"Error": AUTHENTICATION_ERROR_MSG['error']}, status=400)
        else:
            return Response(AUTHENTICATION_ERROR_MSG['error'],status=400)


class LogoutView(APIView):
    authentication_classes = [SessionAuthentication, TokenAuthentication]
    permission_classes = [IsAuthenticated]

    def post(self, request):
        """
        Logout And Session Destroy
        :param request:the request object
        :return: user log out
        """
        logout(request)
        USER_LOGS.info("user --> {} Logged Out Successfully ".format(str(request.user)))
        return Response(AUTHENTICATION_ERROR_MSG['logout'])


class ReversionView(APIView):
    @logger_create
    @SpecificViewDecorator
    def get(self, request, app, model, id):
        """
        To get All the
        Versions History of the Object
        :param request:the request object
        :param app: the app name coming from decorator
        :param model: the model name coming from decorator
        :param id: the id of model for which the versions to be fetched
        :return:  returns the response for all the versions of the particular model
        """
        model = apps.get_model(app, model)
        try:
            objs = model.objects.get(pk=id)
            changes = ReversionDetectChange(objs)
            return Response(changes)
        except ObjectDoesNotExist as e:
            return Response(status=status.HTTP_400_BAD_REQUEST)


class ModelVersions(APIView):
    @logger_create
    @SpecificViewDecorator
    def get(self, request, app, model):
        """
        To get All the
        Versions for particular
        Model
        :param request: the request object
        :param app: the app name coming from decorator
        :param model: the model name coming from decorator
        :return: returns the response for all the versions of the particular model
        """
        model = apps.get_model(app, model)
        ver_list = AllVersions(model)
        return Response(ver_list)


class ExcelExport(APIView):
    # parser_classes = [MultiPartParser, FormParser]
    @SpecificViewDecorator
    def post(self, request, app, model):
        model_obj = apps.get_model(app, model)
        ex = ExcelExportImport.ExcelImportExport(EXCEL_LOGS)
        res = ex.export_to_excel(json.dumps(request.data), model_obj._meta.pk.name)
        response = HttpResponse(res, content_type='application/ms-excel')
        return response


class ListFilter(APIView):
    @ListViewDecorator
    def get(self, request, app, model):
        try:
            if request.GET.__len__() > 0:
                model_obj = apps.get_model(app, model)
                query_dict = request.GET.dict()
                filter_dict={}
                for i in list(query_dict.keys()):
                    if '.name' in i:
                        if FOREIGN_KEY_UI_NAME_MAP[model.lower()]['type']=='integer':
                            filter_dict[FOREIGN_KEY_UI_NAME_MAP[model.lower()]['field']] = NumberFilter(lookup_expr='iexact')
                            old_value = query_dict[i]
                            del query_dict[i]
                            i = FOREIGN_KEY_UI_NAME_MAP[model.lower()]['field']
                            query_dict[i] = old_value
                        if FOREIGN_KEY_UI_NAME_MAP[model.lower()]['type'] == 'text':
                            filter_dict[FOREIGN_KEY_UI_NAME_MAP[model.lower()]['field']] = CharFilter(lookup_expr='iexact')
                            old_value = query_dict[i]
                            del query_dict[i]
                            i = FOREIGN_KEY_UI_NAME_MAP[model.lower()]['field']
                            query_dict[i] = old_value
                    if '_' in query_dict[i]:
                        values = query_dict[i].split('_')
                        op = values[0]
                        value = "_".join(values[1:])
                        query_dict[i] = value
                        if op in FILTER_FIELD_MAPPING['integer']:
                            filter_dict[i] = NumberFilter(field_name=i,lookup_expr=op)
                        elif op in FILTER_FIELD_MAPPING['text']:
                            filter_dict[i] = CharFilter(field_name=i, lookup_expr=op)
                model_filter = genericfilter(model_obj, filter_dict)
                f = model_filter(query_dict, queryset=model_obj.objects.all())
                modelSerializer = check_fields(model_obj)
                serial = modelSerializer(f.qs, many=True, context={"request": request, "group": None})
                return Response(serial.data, status=status.HTTP_200_OK)
            else:
                return Response(status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            REQ_LOGS.exception(e)
            return Response(status=status.HTTP_400_BAD_REQUEST)


class SearchFilter(APIView):
    @ListViewDecorator
    def get(self, request, app, model):
        try:
            DynamicSearchFilter = genericSearch(model)
            model_obj = apps.get_model(app, model)
            model_filter = DynamicSearchFilter()
            objs = model_obj.objects.filter(is_deleted=False).order_by('-last_updated_date')
            final_qs = model_filter.filter_queryset(request, objs, APIView)
            modelSerializer = check_fields(model_obj)
            serial = modelSerializer(final_qs, many=True, context={"request": request, "group": None})
            return Response(serial.data, status=status.HTTP_200_OK)
        except Exception as e:
            REQ_LOGS.exception(e)
            return Response(status=status.HTTP_400_BAD_REQUEST)