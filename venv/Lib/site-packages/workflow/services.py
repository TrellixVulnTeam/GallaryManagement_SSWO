"""
Service Classes for a given module for each entities
"""
from django.apps import apps
from django.conf import settings
from rest_framework import status
from rest_framework.authtoken.models import Token
from rest_framework.response import Response

from workflow import models
from workflow.constants import ACTION_VALIDATOR, WORKFLOW_STATUS
from workflow.entities import WorkflowTransitions, WorkflowLog, ApprovalLinkProxy
from workflow.helper import validate_action_of_workflow
from workflow.models import WorkflowTransactions

APPROVAL_API_URLS = settings.__dict__['_wrapped'].__dict__['APPROVAL_API_URLS']
APPROVAL_GROUPS = settings.__dict__['_wrapped'].__dict__['APPROVAL_GROUPS']


def __get_approver_type(request):
    """
    Get the approver type
    :param request: Django request object
    :return: String - username/groupname, String - Group/User
    """
    common_group = set(request.user.groups.values_list("name", flat=True)) & set(APPROVAL_GROUPS)
    if len(common_group) > 0:
        return next(iter(common_group)), "Group"
    else:
        return request.user.username, "User"


def approval_workflow(**kwargs):
    """
    Purpose: Create a initial state of workflow transaction and process it
    :param kwargs: {request, app, model, pk, action, remarks}
    :return: Current status of the approval workflow
    """

    if kwargs["model"] not in settings.WORKFLOW_MODEL_LIST:
        print("Model not registered with workflow")
        return

    transaction_dict = {"app_name": kwargs["app"], "model_name": kwargs["model"], "request_id": str(kwargs["pk"]),
                        "action": kwargs["action"], "approver": __get_approver_type(kwargs["request"])[0],
                        "approver_type": __get_approver_type(kwargs["request"])[1], "remarks": kwargs["remarks"],
                        "approver_user": kwargs["request"].user.username}
    return __process_workflow(transaction_dict, kwargs)


def __process_workflow(transaction_dict, kwargs):
    """
    Purpose: Processing the approval workflow based on the action and the approver
    :param transaction_dict: Initial state of the current transaction
    :param kwargs: {request, app, model, pk, action, remarks}
    :return: Current status of the approval workflow
    """

    user_action = validate_action_of_workflow(transaction_dict)

    # User approves
    if user_action == ACTION_VALIDATOR["approval"]:

        current_transition = __get_current_transition_by_transaction(transaction_dict)



        if current_transition is None and transaction_dict["approver_type"] == "Group":
            transaction_dict["approver_type"] = "User"
            transaction_dict["approver"] = kwargs["request"].user.username

            current_transition = __get_current_transition_by_transaction(transaction_dict)

        # If approver type is group and current transition is valid and approval strength is not achieved
        # Than stay on the same state, else go to next state

        approval_strength_achieved = __validate_strength_completion(current_transition, transaction_dict)

        if transaction_dict["approver_type"] == "Group" and current_transition and not approval_strength_achieved:

            transaction_dict["current_state"] = current_transition.current_state
            transaction_dict["approver"] = transaction_dict["approver"] + "." + kwargs["request"].user.username

        else:
            transaction_dict["current_state"] = current_transition.next_state

        # If the current transition is not the last transition
        # Than find the next transition, else return the current transition
        if not current_transition.is_last_transition:
            transaction_dict["next_approver"], transaction_dict["next_state"], transaction_dict["next_approver_type"] = \
                __get_next_approver(transaction_dict)

            if not transaction_dict["next_approver"]:
                request_status = "Approved"
                workflow_completed = True
            else:
                request_status = transaction_dict["current_state"]
                workflow_completed = False

        else:
            if transaction_dict["approver_type"] == "Group" and not approval_strength_achieved:
                transaction_dict["next_approver"], transaction_dict["next_state"], transaction_dict[
                    "next_approver_type"] = \
                    __get_next_approver(transaction_dict)
                workflow_completed = True if approval_strength_achieved else False
            else:
                workflow_completed = True
            request_status = current_transition.next_state

    # User rejects
    elif user_action == ACTION_VALIDATOR["rejection"]:
        current_transition = __get_current_transition_by_transaction(transaction_dict)

        if current_transition is None and transaction_dict["approver_type"] == "Group":
            transaction_dict["approver_type"] = "User"
            transaction_dict["approver"] = kwargs["request"].user.username
            current_transition = __get_current_transition_by_transaction(transaction_dict)

        transaction_dict["current_state"] = current_transition.next_state
        transaction_dict["next_approver"] = ""
        transaction_dict["next_state"] = ""
        transaction_dict["next_approver_type"] = ""
        request_status = "Rejected by " + transaction_dict["approver"]
        workflow_completed = False

    # User initiates
    elif user_action == ACTION_VALIDATOR["init"]:
        transaction_dict["current_state"] = WORKFLOW_STATUS['Initiated']

        transaction_dict["next_approver"], transaction_dict["next_state"], transaction_dict["next_approver_type"] = \
            __get_next_approver(transaction_dict)

        request_status = transaction_dict["current_state"]
        workflow_completed = False

    # No action registered
    else:
        print("No Action Found!")
        return "No Action Found!"

    WorkflowLog.objects.create(**transaction_dict)

    return request_status, workflow_completed


def __get_next_approver(transaction_dict):
    """
    Purpose: Get the next approver
    :param transaction_dict: {app_name,model_name,current_state,request_id}
    :return: String - username,groupname, String - next state, String - User/Group
    """

    filters = {
        "app_name": transaction_dict["app_name"],
        "model_name": transaction_dict["model_name"],
        "current_state": transaction_dict["current_state"],
        "action": "Approve"}

    next_transitions = WorkflowTransitions.objects.filter(**filters)

    next_transitions = __validate_constraints(list(next_transitions), transaction_dict["request_id"])

    if next_transitions:

        if next_transitions[0].action_user:
            return next_transitions[0].action_user, next_transitions[0].next_state, "User"
        else:
            return next_transitions[0].action_group, next_transitions[0].next_state, "Group"

    else:
        print("No next transitions found")
        return "", "", ""


def __validate_constraints(next_transitions, pk):
    """
    Purpose: To validate the constraints for the next transitions
    :param next_transitions: List of transitons objects
    :param pk: id of the data on which approval workflow is applied
    :return: boolean
    """

    final_transitions = []

    # Traversing multiple transitions
    for transition in next_transitions:

        # Get all the constraint in a single transition
        constraints = transition.constraints.all()

        # Checking if constraint is available
        if constraints.exists():
            is_all_constraints_valid = True

            # Traversing multiple constraints
            for constraint in constraints:

                # Checking if constraint is satisfied
                if not constraint.is_satisfied(transition, pk):
                    is_all_constraints_valid = False

            if is_all_constraints_valid:
                final_transitions.append(transition)

        else:
            final_transitions.append(transition)

    return final_transitions


def __get_current_transition_by_transaction(transaction_dict):
    """
    Get the current transition by transaction object
    :param transaction_dict: {app_name, model_name, action, approver}
    :return: WorkflowTransition object
    """

    filters = {"model_name": transaction_dict["model_name"],
               "app_name": transaction_dict["app_name"],
               "action": transaction_dict["action"]}

    if transaction_dict["approver_type"] == "User":
        filters["action_user"] = transaction_dict["approver"]
    else:
        filters["action_group"] = transaction_dict["approver"]

    # Determine the actions possible by the user
    current_transition = WorkflowTransitions.objects.filter(**filters).first()
    return current_transition


def __validate_strength_completion(current_transition, transaction_dict, is_before_transaction=True):
    """
    Purpose: To validate the strength of the current transition
    :param current_transition: WorkflowTransition object
    :param transaction_dict: {request_id, model_name, app_name}
    :return: boolean
    """

    if current_transition.approval_strength > 0:
        total_transaction = WorkflowTransactions.objects.filter(request_id=transaction_dict["request_id"],
                                                                model_name=transaction_dict["model_name"],
                                                                app_name=transaction_dict["app_name"],
                                                                approver__contains=current_transition.action_group,
                                                                action=current_transition.action).count()
        if is_before_transaction is True:
            total_transaction = total_transaction + 1
        if total_transaction == current_transition.approval_strength:
            return True
        else:
            return False

    else:
        return False


def get_hierarchy_by_request(request_data):
    """
    Purpose: To generate the hierarchy based on the request by evaluating constraints
    :param request_data: Next request object's data
    :return: Workflow Transitions List
    """
    all_transitions = WorkflowTransitions.objects.filter(model_name=request_data["model_name"],
                                                         app_name=request_data["app_name"]).order_by('level')

    approval_transitions = []

    for transition in list(all_transitions):
        if transition.action == 'Approve':
            approval_transitions.append(transition)

    hierarchy_transitions = __validate_constraints(approval_transitions, request_data["pk"])
    if hierarchy_transitions:
        return hierarchy_transitions
    else:
        return None


def get_all_transactions(request_data):
    all_transactions = WorkflowTransactions.objects.filter(model_name=request_data["model_name"],
                                                           app_name=request_data["app_name"],
                                                           request_id=request_data["pk"])
    return all_transactions


def to_show_approval_button(request, request_id, model_obj):
    """
    Purpose: To show approval button in the workflow section
    :param request: Network request object
    :param request_id: Id of the data on which approval workflow is applied
    :return: boolean
    """

    last_transaction = WorkflowTransactions.objects.filter(request_id=request_id,
                                                           app_name=model_obj._meta.app_label,
                                                           model_name=model_obj._meta.model.__name__).order_by("-id")
    if last_transaction:
        last_transaction = last_transaction[0]
    else:
        return False

    # If the last transaction was of User Init/Approval
    if last_transaction and last_transaction.action == "Approve" or last_transaction.action == "Init":
        groups = request.user.groups.all()
        approval_groups = [group.name for group in groups if group.name in APPROVAL_GROUPS]

        # If user groups exist in approval_groups
        if approval_groups:
            # Iterating each approval group
            for group in approval_groups:
                # If the last transaction's next approver matches with the user's group
                if last_transaction.next_approver == group \
                        and last_transaction.next_approver_type == "Group" \
                        and request.user.username not in last_transaction.approver:
                    return True
        # If the last transaction's next approver matches with the user name
        elif last_transaction.next_approver == request.user.username and last_transaction.next_approver_type == "User":
            return True
    return False


def apply_workflow_action(request):
    """
    Function to proceed with Workflow initiated from the
    approval landing page of a model

    Retrieve token from request
    Verify the token against Approval link entries
    Reject all cases of invalid tokens or inexistent entries
    If valid token, get the model entry against this token
    Process workflow for the model entry and invalidate the current token

    All other valid tokens for the same model entry, will be invalidated.
    For the code, check post_save function for ApprovalProxy

    :return: response with either error or data, with HTTP status code
    :rtype: Response class object
    """

    # TODO Recheck if this function is repeating any of the WorkflowAuthentication class methods

    approval_token = request.META.get('HTTP_APPROVAL_AUTHORIZATION')
    is_token_exists = ApprovalLinkProxy.objects.filter(approval_token=approval_token)
    if is_token_exists.exists():
        token_in_db = ApprovalLinkProxy.objects.filter(approval_token=approval_token)
        token = token_in_db.first()

        app = token.app
        model = token.model
        request_id = token.request_id
    else:
        data = request.data
        app = data['app_name']
        model = data['model_name']
        request_id = data['id']

    context_model = apps.get_model(app, model)
    context_object = context_model.objects.filter(pk=request_id)

    if not context_object.exists():
        return Response({"error": "No such model was found"},
                        status=status.HTTP_404_NOT_FOUND)
    else:
        # IDEA : Object found, process workflow and update the model
        this_object = context_object.first()

        this_object.status, this_object.is_approved = approval_workflow(app=app,
                                                                        model=model,
                                                                        pk=this_object.pk,
                                                                        action=request.data["action"],
                                                                        remarks=request.data.get("remarks"),
                                                                        request=request)

        # used save to allow for any event triggers to happen smoothly

        this_object.save()

        if is_token_exists.exists():
            last_transaction = WorkflowTransactions.objects.filter(app_name=app, model_name=model,
                                                                   request_id=request_id).last()

            if last_transaction.approver_type == "Group":
                current_transition = WorkflowTransitions.objects.filter(
                    app_name=app,
                    model_name=model,
                    next_state=last_transaction.next_state).first()
                to_invalidate_all = __validate_strength_completion(current_transition, last_transaction.__dict__, False)
                token.self_invalidate(to_invalidate_all)
            else:
                token.self_invalidate()

        return Response({}, status=status.HTTP_200_OK)


def get_model_info(request):
    approval_token = request.META.get('HTTP_APPROVAL_AUTHORIZATION')
    default_dict = {}

    token_found = models.ApprovalLinkSent.objects.filter(approval_token=approval_token, approver=request.user,
                                                         is_valid=True)

    if token_found.exists():
        token = token_found.first()
        default_dict['app'] = token.app
        default_dict['model'] = token.model
        default_dict['request_id'] = token.request_id
        default_dict['username'] = request.user.username

        auth_token, created = Token.objects.get_or_create(user=request.user)

        default_dict['auth_token'] = '"Token {}"'.format(auth_token.key)

        url = APPROVAL_API_URLS[token.model.lower()]

        if url:
            default_dict['approval_api_url'] = url.format(pk=str(token.request_id))

        return default_dict
    return {}


def has_crossed_approval_strength(current_transition, transaction_dict):
    """
    This function is a clone of __validate
    :param current_transition:
    :param transaction_dict:
    :return:
    """
    if current_transition.approval_strength > 0:
        total_transaction = WorkflowTransactions.objects.filter(request_id=transaction_dict["request_id"],
                                                                model_name=transaction_dict["model_name"],
                                                                app_name=transaction_dict["app_name"],
                                                                approver__contains=current_transition.action_group,
                                                                action=current_transition.action).count()

        if total_transaction == current_transition.approval_strength:
            return True
        else:
            return False
    else:
        return False
