# pylint: disable = R0903
"""
Proxy models which contains the Business Logic related to business model.
Each functions should be atomic and single responsibility.
The methods should be pure methods should not use anything other than instance variables and args.

"""

import traceback

from django.conf import settings
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils.crypto import get_random_string
from django.utils.module_loading import import_string

from workflow import models
from workflow.email_policy import get_workflow_email_config, get_request_initiator
from api.logger_directory import requests_logger
from commons.mail_utils import prepare_email_message, send_email

REQ_LOGS = requests_logger()

WORKFLOW_MAIL_MAP = settings.__dict__['_wrapped'].__dict__['WORKFLOW_MAIL_MAP']
MODELS_WITH_MAIL_APPROVAL = settings.__dict__['_wrapped'].__dict__['MODELS_WITH_MAIL_APPROVAL']
LANDING_PAGE_FMT = settings.__dict__['_wrapped'].__dict__['LANDING_PAGE_FMT']

class WorkflowAction(models.WorkflowActionMaster):

    def is_approval(self):
        return self.action_type == 'Approve'

    def is_rejection(self):
        return self.action_type == 'Reject'

    def is_init(self):
        return self.action_type == 'Init'

    def is_improvement(self):
        return self.action_type == 'Improve'

    class Meta:
        proxy = True


class WorkflowConstraints(models.WorkflowConstraintsMaster):
    class Meta:
        proxy = True


class WorkflowTransitions(models.WorkflowTransitionsMaster):
    class Meta:
        proxy = True


class WorkflowLog(models.WorkflowTransactions):
    class Meta:
        proxy = True


@receiver(post_save, sender=WorkflowLog)
def workflowlog_postsave(sender, instance, **kwargs):
    print("kwargs : {}".format(kwargs))

    if kwargs.get('created', True):
        # IDEA : When new entry is created, get users by email_policy, prepare and send email

        REQ_LOGS.debug("Postsave on Workflow log {} has been triggered".format(instance.pk))
        try:
            trigger_mail_on_workflow(instance)
        except Exception as exc:
            REQ_LOGS.exception(traceback.format_exc())


def trigger_mail_on_workflow(instance):
    users = []
    mail_subject = 'APPROVAL REQUEST'
    extra_args = {}

    actual_action = WorkflowAction.objects.filter(action_label=instance.action) \
        .values_list('action_type', flat=True).first()

    # Get the hook config

    hook_config = get_workflow_email_config(instance.app_name, instance.model_name, actual_action)
    is_final_state = WorkflowTransitions.objects.filter(is_last_transition=True, model_name=instance.model_name,
                                                        next_state=instance.current_state).exists()

    cc_list = get_request_initiator(instance) if not is_final_state else []

    if not hook_config:
        REQ_LOGS.warn("Did not receive a valid hook, mail(s) will not be sent")
        return

    for notification_type, hook_path in hook_config.items():
        # For each notification type:
        # Step 0. Import function from the dotted path
        if notification_type == 'request' and is_final_state:
            # If this is the final state, we don't need to send a approval request
            continue

        if is_final_state and actual_action == 'Approve':
            users = get_request_initiator(instance)
        else:
            try:
                REQ_LOGS.info("Importing function from path : {}".format(hook_path))
                hook_method = import_string(hook_path)
                # Step 1. get users using the function
                users = hook_method(instance)
            except ImportError as error:
                REQ_LOGS.error("Exception led to aborting mails")
                REQ_LOGS.error(traceback.format_exc())
                return

        print("Users found : {}".format(users))

        # Step 2. prepare message dictionary

        if is_final_state and actual_action == 'Approve':
            email_code = WORKFLOW_MAIL_MAP[instance.model_name]['Final']
        else:
            email_code = WORKFLOW_MAIL_MAP[instance.model_name][actual_action]

        if not is_final_state and notification_type == 'request' \
                and instance.model_name in MODELS_WITH_MAIL_APPROVAL:

            # TODO Test this code with multiple users
            # Step 0 : Create entry in ApprovalLink against user

            if ApprovalLinkProxy.objects.filter(request_id=instance.request_id, app=instance.app_name,
                                                model=instance.model_name, receiver_email__in=users,
                                                is_valid=True).exists():
                # IDEA: Skip sending emails to users if there are already valid links
                continue

            for each_user in users:
                REQ_LOGS.info("User : {}".format(each_user))
                REQ_LOGS.info("Into creating approval entry")

                username = User.objects.filter(email=each_user).first().username

                approval_entry = create_approval_link_entry(instance, username, each_user)

                extra_args['open_landing_page'] = LANDING_PAGE_FMT.format(approval_entry.approval_token)
                extra_args['notification_type'] = 'request'

                REQ_LOGS.info("=================================================================================")
                REQ_LOGS.info("|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n")
                REQ_LOGS.info("\n APPROVAL_URL : {}\n".format(extra_args['open_landing_page']))
                REQ_LOGS.info("\n VPN APPROVAL_URL : {}\n".format(extra_args['vpn_landing_page']))
                REQ_LOGS.info("|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n")
                REQ_LOGS.info("=================================================================================")

                approval_request = prepare_email_message(email_code, mail_subject, [each_user, ], [],
                                                         instance, extra_args)

                print("REQUEST TO LIST : {}".format(each_user))

                send_email(approval_request)

            # After sending all approval requests move onto next notification type
            continue

        if notification_type == 'notification':
            mail_subject = 'NOTIFICATION'
        elif notification_type == 'request':
            mail_subject = 'APPROVAL REQUEST'

        message = prepare_email_message(email_code, mail_subject, users, cc_list, instance,
                                        {"notification_type": notification_type})

        print("NOTIFCATION TO LIST : {}".format(users))
        print("NOTIFCATION TO LIST : {}".format(cc_list))

        # Step 3. send email
        send_email(message)


class ApprovalLinkProxy(models.ApprovalLinkSent):
    """
    Proxy model for ApprovalLinkSent
    """

    def self_invalidate(self, to_invalidate_all=True):
        """
        Invalidate any approval attempts using this current approval_token
        by setting has_expired to True
        """
        self.is_valid = False
        self._invalidate_others = to_invalidate_all
        self.save()

    class Meta:
        proxy = True


@receiver(post_save, sender=ApprovalLinkProxy)
def approvalproxy_postsave(sender, instance, **kwargs):
    REQ_LOGS.debug("POSTSAVE signal triggered")
    if not kwargs.get('created'):
        REQ_LOGS.info("ApprovalLinkSent ID {} was updated".format(instance.pk))
        if hasattr(instance, '_invalidate_others'):
            # IDEA: Invalidate all other approval links for the same model entry

            if instance._invalidate_others is False:
                return

            REQ_LOGS.debug("Entering section : Expire approval links for same model")
            # deleting temporary flag
            del instance._invalidate_others

            REQ_LOGS.info("Finding any valid links for {} object, ID {}".format(instance.model,
                                                                                instance.request_id))
            other_active_links = ApprovalLinkProxy.objects \
                .filter(
                app=instance.app,
                model=instance.model,
                request_id=instance.request_id,
                is_valid=True)

            if other_active_links.exists():
                REQ_LOGS.info("There are {} approval links to expire".format(
                    other_active_links.count()))
                is_updated = other_active_links.update(is_valid=False)

                REQ_LOGS.info("Return value : {}, Type : {}".format(is_updated, type(is_updated)))
            else:
                REQ_LOGS.info("Could not find any valid approval links to expire")

            # Invalidate all tokens for the current user and the guest user
            # Token.objects.filter(user__username__in=[instance.approver, 'guest']).delete()

            REQ_LOGS.debug("Leaving section : Expire approval links for same model")


# TODO Make default_hook optional
def create_approval_link_entry(workflow_log, username, receiver_email):
    """
    QUESTION : Is this an entity function ?
    Function to create Approval Link entries
    These entries will be the reference when approval POST
    requests will be made from the landing page

    :param workflow_log: Workflow log recieved from postsave call
    :type workflow_log: WorkflowState object
    :param receiver_email: Receiver email
    :type receiver_email
    :return:
    """
    # QUESTION : receiver_email is a list of email addresses. Is this okay ?

    approval_entry = ApprovalLinkProxy.objects.create(
        approval_token=get_random_string(),
        app=workflow_log.app_name,
        model=workflow_log.model_name,
        request_id=workflow_log.request_id,
        approver=username,
        receiver_email=receiver_email
    )

    return approval_entry
